<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Website</title>
  <style>
    body { margin: 0; background: #444; overflow: hidden; font-family: sans-serif; }
    .slider-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; gap: 10px; z-index: 10; width: 220px; color: #fff; font-size: 14px; }
    .slider-container label { text-align: center; }
  </style>
</head>
<body>
  <div class="slider-container">
    <label>Zoom</label>
    <input type="range" min="1" max="10" step="0.1" value="3" id="zoomControl">

    <label>Rotate X</label>
    <input type="range" min="-3.14" max="3.14" step="0.01" value="0" id="rotX">

    <label>Rotate Y</label>
    <input type="range" min="-3.14" max="3.14" step="0.01" value="0" id="rotY">

    <label>Rotate Z</label>
    <input type="range" min="-3.14" max="3.14" step="0.01" value="0" id="rotZ">

    <label>Rotate W</label>
    <input type="range" min="-3.14" max="3.14" step="0.01" value="0" id="rotW">
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.PointLight(0xffffff, 1);
    camera.add(light);
    scene.add(camera);

    function createTesseractGeometry(size) {
      const vertices4D = [];
      for (let x of [-1,1])
      for (let y of [-1,1])
      for (let z of [-1,1])
      for (let w of [-1,1])
        vertices4D.push(new THREE.Vector4(x, y, z, w));
      const edges = [];
      for (let i = 0; i < vertices4D.length; i++) {
        for (let j = i + 1; j < vertices4D.length; j++) {
          const diff = vertices4D[i].clone().sub(vertices4D[j]).toArray().map(Math.abs);
          if (diff.filter(v => v === 2).length === 1) edges.push([i, j]);
        }
      }
      return { vertices4D, edges };
    }

    const t = createTesseractGeometry(1);

    let material = new THREE.LineBasicMaterial({ color: 0xffffff });
    let geo = new THREE.BufferGeometry();
    let lineSegments = new THREE.LineSegments(geo, material);
    scene.add(lineSegments);

    function rotate4D(v, axis1, axis2, angle) {
      const c = Math.cos(angle), s = Math.sin(angle);
      const a = v[axis1], b = v[axis2];
      v[axis1] = a * c - b * s;
      v[axis2] = a * s + b * c;
    }

    const rotX = document.getElementById('rotX');
    const rotY = document.getElementById('rotY');
    const rotZ = document.getElementById('rotZ');
    const rotW = document.getElementById('rotW');

    camera.position.z = 5;

    function animate() {
      requestAnimationFrame(animate);

      let pts = [];

      for (let v of t.vertices4D) {
        let p = v.clone();
        rotate4D(p, 0, 3, parseFloat(rotW.value));
        rotate4D(p, 1, 3, parseFloat(rotW.value)); 
        rotate4D(p, 2, 3, parseFloat(rotW.value)); 
        rotate4D(p, 1, 2, parseFloat(rotX.value));
        rotate4D(p, 0, 2, parseFloat(rotY.value));
        rotate4D(p, 0, 1, parseFloat(rotZ.value));
        let wFactor = 1 / (2 - p.w);
        pts.push(new THREE.Vector3(p.x * wFactor, p.y * wFactor, p.z * wFactor));
      }

      const positions = [];
      for (const e of t.edges) {
        positions.push(pts[e[0]].x, pts[e[0]].y, pts[e[0]].z);
        positions.push(pts[e[1]].x, pts[e[1]].y, pts[e[1]].z);
      }

      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geo.computeBoundingSphere();

      renderer.render(scene, camera);
    }

    animate();

  </script>
</body>
</html>
