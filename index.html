<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tesseract Fixed</title>
  <style>
    body { margin: 0; background: #444; overflow: hidden; font-family: sans-serif; }
    .slider-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; gap: 10px; z-index: 10; width: 220px; color: #fff; font-size: 14px; }
    .slider-container label { text-align: center; }
  </style>
</head>
<body>
  <div class="slider-container">
    <label>Zoom</label>
    <input type="range" min="1" max="10" step="0.1" value="5" id="zoomControl">

    <label>Rotate X</label>
    <input type="range" min="-3.14" max="3.14" step="0.01" value="0" id="rotX">

    <label>Rotate Y</label>
    <input type="range" min="-3.14" max="3.14" step="0.01" value="0" id="rotY">

    <label>Rotate Z</label>
    <input type="range" min="-3.14" max="3.14" step="0.01" value="0" id="rotZ">

    <label>Rotate W</label>
    <input type="range" min="-3.14" max="3.14" step="0.01" value="0" id="rotW">
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.PointLight(0xffffff, 1);
    camera.add(light);
    scene.add(camera);

    function createTesseract() {
      const vertices = [];
      for (let x of [-1,1])
      for (let y of [-1,1])
      for (let z of [-1,1])
      for (let w of [-1,1])
        vertices.push(new THREE.Vector4(x, y, z, w));

      const edges = [];
      for (let i = 0; i < vertices.length; i++) {
        for (let j = i + 1; j < vertices.length; j++) {
          const diff = vertices[i].clone().sub(vertices[j]).toArray().map(Math.abs);
          if (diff.filter(v => v === 2).length === 1) edges.push([i, j]);
        }
      }
      return { vertices, edges };
    }

    const tesseract = createTesseract();
    let geo = new THREE.BufferGeometry();
    let lines = new THREE.LineSegments(geo, new THREE.LineBasicMaterial({ color: 0xffffff }));
    scene.add(lines);

    function rotate4D(v, a, b, angle) {
      const c = Math.cos(angle), s = Math.sin(angle);
      const va = v[a], vb = v[b];
      v[a] = va*c - vb*s;
      v[b] = va*s + vb*c;
    }

    const rotX = document.getElementById('rotX');
    const rotY = document.getElementById('rotY');
    const rotZ = document.getElementById('rotZ');
    const rotW = document.getElementById('rotW');
    const zoom = document.getElementById('zoomControl');

    camera.position.z = 6;

    function animate() {
      requestAnimationFrame(animate);

      camera.position.z = parseFloat(zoom.value);

      const pts = [];
      for (let v of tesseract.vertices) {
        const p = v.clone();
        rotate4D(p, 0, 3, parseFloat(rotW.value));
        rotate4D(p, 1, 3, parseFloat(rotW.value));
        rotate4D(p, 2, 3, parseFloat(rotW.value));
        rotate4D(p, 1, 2, parseFloat(rotX.value));
        rotate4D(p, 0, 2, parseFloat(rotY.value));
        rotate4D(p, 0, 1, parseFloat(rotZ.value));

        const wFactor = 1 / (2 - p.w);
        pts.push(new THREE.Vector3(p.x*wFactor, p.y*wFactor, p.z*wFactor));
      }

      const pos = [];
      for (let e of tesseract.edges) {
        pos.push(pts[e[0]].x, pts[e[0]].y, pts[e[0]].z);
        pos.push(pts[e[1]].x, pts[e[1]].y, pts[e[1]].z);
      }

      geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
      geo.computeBoundingSphere();

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
